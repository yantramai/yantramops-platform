{
  "version": 4,
  "terraform_version": "1.0.1",
  "serial": 3,
  "lineage": "b8124c54-0ee5-b4f4-c57d-52286b8c146c",
  "outputs": {},
  "resources": [
    {
      "module": "module.helm_chart",
      "mode": "managed",
      "type": "helm_release",
      "name": "yantram-helm_release-stack",
      "provider": "provider[\"registry.terraform.io/hashicorp/helm\"]",
      "instances": [
        {
          "index_key": "postgresql",
          "schema_version": 0,
          "attributes": {
            "atomic": false,
            "chart": "postgresql",
            "cleanup_on_fail": false,
            "create_namespace": false,
            "dependency_update": false,
            "description": null,
            "devel": null,
            "disable_crd_hooks": false,
            "disable_openapi_validation": false,
            "disable_webhooks": false,
            "force_update": false,
            "id": "yantram-postgresql",
            "keyring": null,
            "lint": false,
            "manifest": null,
            "max_history": 0,
            "metadata": [
              {
                "app_version": "14.4.0",
                "chart": "postgresql",
                "name": "yantram-postgresql",
                "namespace": "yantram",
                "revision": 1,
                "values": "{\"audit\":{\"clientMinMessages\":\"error\",\"logConnections\":false,\"logDisconnections\":false,\"logHostname\":false,\"logLinePrefix\":\"\",\"logTimezone\":\"\",\"pgAuditLog\":\"\",\"pgAuditLogCatalog\":\"off\"},\"commonAnnotations\":{},\"containerSecurityContext\":{\"enabled\":true,\"runAsUser\":1001},\"customLivenessProbe\":{},\"customReadinessProbe\":{},\"customStartupProbe\":{},\"extraEnv\":[],\"global\":{\"postgresql\":{}},\"image\":{\"debug\":false,\"pullPolicy\":\"IfNotPresent\",\"registry\":\"docker.io\",\"repository\":\"bitnami/postgresql\",\"tag\":\"11.11.0-debian-10-r14\"},\"ldap\":{\"baseDN\":\"\",\"bindDN\":\"\",\"bind_password\":null,\"enabled\":false,\"port\":\"\",\"prefix\":\"\",\"scheme\":\"\",\"search_attr\":\"\",\"search_filter\":\"\",\"server\":\"\",\"suffix\":\"\",\"tls\":{},\"url\":\"\"},\"livenessProbe\":{\"enabled\":true,\"failureThreshold\":6,\"initialDelaySeconds\":30,\"periodSeconds\":10,\"successThreshold\":1,\"timeoutSeconds\":5},\"networkPolicy\":{\"allowExternal\":true,\"enabled\":false,\"explicitNamespacesSelector\":{}},\"persistence\":{\"accessModes\":[\"ReadWriteOnce\"],\"annotations\":{},\"enabled\":true,\"mountPath\":\"/bitnami/postgresql\",\"selector\":{},\"size\":\"8Gi\",\"subPath\":\"\"},\"pgHbaConfiguration\":\"host  all  all 0.0.0.0/0 trust\",\"postgresqlDataDir\":\"/bitnami/postgresql/data\",\"postgresqlDatabase\":\"postgres\",\"postgresqlDbUserConnectionLimit\":null,\"postgresqlMaxConnections\":null,\"postgresqlPassword\":\"postgres\",\"postgresqlPghbaRemoveFilters\":null,\"postgresqlPostgresConnectionLimit\":null,\"postgresqlSharedPreloadLibraries\":\"pgaudit\",\"postgresqlStatementTimeout\":null,\"postgresqlTcpKeepalivesCount\":null,\"postgresqlTcpKeepalivesIdle\":null,\"postgresqlTcpKeepalivesInterval\":null,\"postgresqlUsername\":\"postgres\",\"primary\":{\"affinity\":{},\"annotations\":{},\"extraInitContainers\":[],\"extraVolumeMounts\":[],\"extraVolumes\":[],\"labels\":{},\"nodeAffinityPreset\":{\"key\":\"\",\"type\":\"\",\"values\":[]},\"nodeSelector\":{},\"podAffinityPreset\":\"\",\"podAnnotations\":{},\"podAntiAffinityPreset\":\"soft\",\"podLabels\":{},\"priorityClassName\":\"\",\"service\":{},\"sidecars\":[],\"tolerations\":[]},\"primaryAsStandBy\":{\"enabled\":false},\"psp\":{\"create\":false},\"rbac\":{\"create\":false},\"readReplicas\":{\"affinity\":{},\"annotations\":{},\"extraInitContainers\":[],\"extraVolumeMounts\":[],\"extraVolumes\":[],\"labels\":{},\"nodeAffinityPreset\":{\"key\":\"\",\"type\":\"\",\"values\":[]},\"nodeSelector\":{},\"persistence\":{\"enabled\":true},\"podAffinityPreset\":\"\",\"podAnnotations\":{},\"podAntiAffinityPreset\":\"soft\",\"podLabels\":{},\"priorityClassName\":\"\",\"resources\":{},\"service\":{},\"sidecars\":[],\"tolerations\":[]},\"readinessProbe\":{\"enabled\":true,\"failureThreshold\":6,\"initialDelaySeconds\":5,\"periodSeconds\":10,\"successThreshold\":1,\"timeoutSeconds\":5},\"replication\":{\"applicationName\":\"my_application\",\"enabled\":false,\"numSynchronousReplicas\":0,\"password\":\"repl_password\",\"readReplicas\":1,\"synchronousCommit\":\"off\",\"user\":\"repl_user\"},\"resources\":{\"requests\":{\"cpu\":\"250m\",\"memory\":\"256Mi\"}},\"securityContext\":{\"enabled\":true,\"fsGroup\":1001},\"service\":{\"annotations\":{},\"port\":5432,\"type\":\"ClusterIP\"},\"serviceAccount\":{\"enabled\":false},\"shmVolume\":{\"chmod\":{\"enabled\":true},\"enabled\":true},\"startupProbe\":{\"enabled\":false,\"failureThreshold\":10,\"initialDelaySeconds\":30,\"periodSeconds\":15,\"successThreshold\":1,\"timeoutSeconds\":5},\"tls\":{\"certCAFilename\":null,\"certFilename\":\"\",\"certKeyFilename\":\"\",\"certificatesSecret\":\"\",\"crlFilename\":null,\"enabled\":false,\"preferServerCiphers\":true},\"updateStrategy\":{\"type\":\"RollingUpdate\"},\"volumePermissions\":{\"enabled\":false,\"image\":{\"pullPolicy\":\"Always\",\"registry\":\"docker.io\",\"repository\":\"bitnami/bitnami-shell\",\"tag\":\"10\"},\"securityContext\":{\"runAsUser\":0}}}",
                "version": "11.6.15"
              }
            ],
            "name": "yantram-postgresql",
            "namespace": "yantram",
            "pass_credentials": false,
            "postrender": [],
            "recreate_pods": false,
            "render_subchart_notes": true,
            "replace": false,
            "repository": "https://charts.bitnami.com/bitnami",
            "repository_ca_file": null,
            "repository_cert_file": null,
            "repository_key_file": null,
            "repository_password": null,
            "repository_username": null,
            "reset_values": false,
            "reuse_values": false,
            "set": [],
            "set_sensitive": [],
            "skip_crds": false,
            "status": "deployed",
            "timeout": 300,
            "values": [
              "## Global Docker image parameters\n## Please, note that this will override the image parameters, including dependencies, configured to use the global value\n## Current available global Docker image parameters: imageRegistry and imagePullSecrets\n##\nglobal:\n  postgresql: {}\n#   imageRegistry: myRegistryName\n#   imagePullSecrets:\n#     - myRegistryKeySecretName\n#   storageClass: myStorageClass\n\n## Bitnami PostgreSQL image version\n## ref: https://hub.docker.com/r/bitnami/postgresql/tags/\n##\nimage:\n  registry: docker.io\n  repository: bitnami/postgresql\n  tag: 11.11.0-debian-10-r14\n  ## Specify a imagePullPolicy\n  ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'\n  ## ref: http://kubernetes.io/docs/user-guide/images/#pre-pulling-images\n  ##\n  pullPolicy: IfNotPresent\n  ## Optionally specify an array of imagePullSecrets.\n  ## Secrets must be manually created in the namespace.\n  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/\n  ##\n  # pullSecrets:\n  #   - myRegistryKeySecretName\n\n  ## Set to true if you would like to see extra information on logs\n  ## It turns BASH and NAMI debugging in minideb\n  ## ref:  https://github.com/bitnami/minideb-extras/#turn-on-bash-debugging\n  ##\n  debug: false\n\n## String to partially override common.names.fullname template (will maintain the release name)\n##\n# nameOverride:\n\n## String to fully override common.names.fullname template\n##\n# fullnameOverride:\n\n##\n## Init containers parameters:\n## volumePermissions: Change the owner of the persist volume mountpoint to RunAsUser:fsGroup\n##\nvolumePermissions:\n  enabled: false\n  image:\n    registry: docker.io\n    repository: bitnami/bitnami-shell\n    tag: \"10\"\n    ## Specify a imagePullPolicy\n    ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'\n    ## ref: http://kubernetes.io/docs/user-guide/images/#pre-pulling-images\n    ##\n    pullPolicy: Always\n    ## Optionally specify an array of imagePullSecrets.\n    ## Secrets must be manually created in the namespace.\n    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/\n    ##\n    # pullSecrets:\n    #   - myRegistryKeySecretName\n  ## Init container Security Context\n  ## Note: the chown of the data folder is done to securityContext.runAsUser\n  ## and not the below volumePermissions.securityContext.runAsUser\n  ## When runAsUser is set to special value \"auto\", init container will try to chwon the\n  ## data folder to autodetermined user\u0026group, using commands: `id -u`:`id -G | cut -d\" \" -f2`\n  ## \"auto\" is especially useful for OpenShift which has scc with dynamic userids (and 0 is not allowed).\n  ## You may want to use this volumePermissions.securityContext.runAsUser=\"auto\" in combination with\n  ## pod securityContext.enabled=false and shmVolume.chmod.enabled=false\n  ##\n  securityContext:\n    runAsUser: 0\n\n## Use an alternate scheduler, e.g. \"stork\".\n## ref: https://kubernetes.io/docs/tasks/administer-cluster/configure-multiple-schedulers/\n##\n# schedulerName:\n\n## Pod Security Context\n## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/\n##\nsecurityContext:\n  enabled: true\n  fsGroup: 1001\n\n## Container Security Context\n## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/\n##\ncontainerSecurityContext:\n  enabled: true\n  runAsUser: 1001\n\n## Pod Service Account\n## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/\n##\nserviceAccount:\n  enabled: false\n  ## Name of an already existing service account. Setting this value disables the automatic service account creation.\n  # name:\n\n## Pod Security Policy\n## ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/\n##\npsp:\n  create: false\n\n## Creates role for ServiceAccount\n## Required for PSP\n##\nrbac:\n  create: false\n\nreplication:\n  enabled: false\n  user: repl_user\n  password: repl_password\n  readReplicas: 1\n  ## Set synchronous commit mode: on, off, remote_apply, remote_write and local\n  ## ref: https://www.postgresql.org/docs/9.6/runtime-config-wal.html#GUC-WAL-LEVEL\n  synchronousCommit: 'off'\n  ## From the number of `readReplicas` defined above, set the number of those that will have synchronous replication\n  ## NOTE: It cannot be \u003e readReplicas\n  numSynchronousReplicas: 0\n  ## Replication Cluster application name. Useful for defining multiple replication policies\n  ##\n  applicationName: my_application\n\n## PostgreSQL admin password (used when `postgresqlUsername` is not `postgres`)\n## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md#creating-a-database-user-on-first-run (see note!)\n# postgresqlPostgresPassword:\n\n## PostgreSQL user (has superuser privileges if username is `postgres`)\n## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md#setting-the-root-password-on-first-run\n##\npostgresqlUsername: postgres\n\n## PostgreSQL password\n## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md#setting-the-root-password-on-first-run\n##\npostgresqlPassword: postgres\n\n## PostgreSQL password using existing secret\n## existingSecret: secret\n##\n\n## Mount PostgreSQL secret as a file instead of passing environment variable\n# usePasswordFile: false\n\n## Create a database\n## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md#creating-a-database-on-first-run\n##\npostgresqlDatabase: postgres\n\n## PostgreSQL data dir\n## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md\n##\npostgresqlDataDir: /bitnami/postgresql/data\n\n## An array to add extra environment variables\n## For example:\n## extraEnv:\n##   - name: FOO\n##     value: \"bar\"\n##\n# extraEnv:\nextraEnv: []\n\n## Name of a ConfigMap containing extra env vars\n##\n# extraEnvVarsCM:\n\n## Specify extra initdb args\n## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md\n##\n# postgresqlInitdbArgs:\n\n## Specify a custom location for the PostgreSQL transaction log\n## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md\n##\n# postgresqlInitdbWalDir:\n\n## PostgreSQL configuration\n## Specify runtime configuration parameters as a dict, using camelCase, e.g.\n## {\"sharedBuffers\": \"500MB\"}\n## Alternatively, you can put your postgresql.conf under the files/ directory\n## ref: https://www.postgresql.org/docs/current/static/runtime-config.html\n##\n# postgresqlConfiguration:\n\n## PostgreSQL extended configuration\n## As above, but _appended_ to the main configuration\n## Alternatively, you can put your *.conf under the files/conf.d/ directory\n## https://github.com/bitnami/bitnami-docker-postgresql#allow-settings-to-be-loaded-from-files-other-than-the-default-postgresqlconf\n##\n# postgresqlExtendedConf:\n\n## Configure current cluster's primary server to be the standby server in other cluster.\n## This will allow cross cluster replication and provide cross cluster high availability.\n## You will need to configure pgHbaConfiguration if you want to enable this feature with local cluster replication enabled.\n##\nprimaryAsStandBy:\n  enabled: false\n  #  primaryHost:\n  #  primaryPort:\n\n## PostgreSQL client authentication configuration\n## Specify content for pg_hba.conf\n## Default: do not create pg_hba.conf\n## Alternatively, you can put your pg_hba.conf under the files/ directory\npgHbaConfiguration: |-\n  host  all  all 0.0.0.0/0 trust\n\n#   host mydatabase mysuser 192.168.0.0/24 md5\n\n## ConfigMap with PostgreSQL configuration\n## NOTE: This will override postgresqlConfiguration and pgHbaConfiguration\n# configurationConfigMap:\n\n## ConfigMap with PostgreSQL extended configuration\n# extendedConfConfigMap:\n\n## initdb scripts\n## Specify dictionary of scripts to be run at first boot\n## Alternatively, you can put your scripts under the files/docker-entrypoint-initdb.d directory\n##\n# initdbScripts:\n#   my_init_script.sh: |\n#      #!/bin/sh\n#      echo \"Do something.\"\n\n## ConfigMap with scripts to be run at first boot\n## NOTE: This will override initdbScripts\n# initdbScriptsConfigMap:\n\n## Secret with scripts to be run at first boot (in case it contains sensitive information)\n## NOTE: This can work along initdbScripts or initdbScriptsConfigMap\n# initdbScriptsSecret:\n\n## Specify the PostgreSQL username and password to execute the initdb scripts\n# initdbUser:\n# initdbPassword:\n\n## Audit settings\n## https://github.com/bitnami/bitnami-docker-postgresql#auditing\n##\naudit:\n  ## Log client hostnames\n  ##\n  logHostname: false\n  ## Log connections to the server\n  ##\n  logConnections: false\n  ## Log disconnections\n  ##\n  logDisconnections: false\n  ## Operation to audit using pgAudit (default if not set)\n  ##\n  pgAuditLog: \"\"\n  ## Log catalog using pgAudit\n  ##\n  pgAuditLogCatalog: \"off\"\n  ## Log level for clients\n  ##\n  clientMinMessages: error\n  ## Template for log line prefix (default if not set)\n  ##\n  logLinePrefix: \"\"\n  ## Log timezone\n  ##\n  logTimezone: \"\"\n\n## Shared preload libraries\n##\npostgresqlSharedPreloadLibraries: \"pgaudit\"\n\n## Maximum total connections\n##\npostgresqlMaxConnections:\n\n## Maximum connections for the postgres user\n##\npostgresqlPostgresConnectionLimit:\n\n## Maximum connections for the created user\n##\npostgresqlDbUserConnectionLimit:\n\n## TCP keepalives interval\n##\npostgresqlTcpKeepalivesInterval:\n\n## TCP keepalives idle\n##\npostgresqlTcpKeepalivesIdle:\n\n## TCP keepalives count\n##\npostgresqlTcpKeepalivesCount:\n\n## Statement timeout\n##\npostgresqlStatementTimeout:\n\n## Remove pg_hba.conf lines with the following comma-separated patterns\n## (cannot be used with custom pg_hba.conf)\n##\npostgresqlPghbaRemoveFilters:\n\n## Optional duration in seconds the pod needs to terminate gracefully.\n## ref: https://kubernetes.io/docs/concepts/workloads/pods/pod/#termination-of-pods\n##\n# terminationGracePeriodSeconds: 30\n\n## LDAP configuration\n##\nldap:\n  enabled: false\n  url: ''\n  server: ''\n  port: ''\n  prefix: ''\n  suffix: ''\n  baseDN: ''\n  bindDN: ''\n  bind_password:\n  search_attr: ''\n  search_filter: ''\n  scheme: ''\n  tls: {}\n\n## PostgreSQL service configuration\n##\nservice:\n  ## PosgresSQL service type\n  ##\n  type: ClusterIP\n  # clusterIP: None\n  port: 5432\n\n  ## Specify the nodePort value for the LoadBalancer and NodePort service types.\n  ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport\n  ##\n  # nodePort:\n\n  ## Provide any additional annotations which may be required. Evaluated as a template.\n  ##\n  annotations: {}\n  ## Set the LoadBalancer service type to internal only.\n  ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#internal-load-balancer\n  ##\n  # loadBalancerIP:\n  ## Load Balancer sources. Evaluated as a template.\n  ## https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/#restrict-access-for-loadbalancer-service\n  ##\n  # loadBalancerSourceRanges:\n  # - 10.10.10.0/24\n\n## Start primary and read(s) pod(s) without limitations on shm memory.\n## By default docker and containerd (and possibly other container runtimes)\n## limit `/dev/shm` to `64M` (see e.g. the\n## [docker issue](https://github.com/docker-library/postgres/issues/416) and the\n## [containerd issue](https://github.com/containerd/containerd/issues/3654),\n## which could be not enough if PostgreSQL uses parallel workers heavily.\n##\nshmVolume:\n  ## Set `shmVolume.enabled` to `true` to mount a new tmpfs volume to remove\n  ## this limitation.\n  ##\n  enabled: true\n  ## Set to `true` to `chmod 777 /dev/shm` on a initContainer.\n  ## This option is ignored if `volumePermissions.enabled` is `false`\n  ##\n  chmod:\n    enabled: true\n\n## PostgreSQL data Persistent Volume Storage Class\n## If defined, storageClassName: \u003cstorageClass\u003e\n## If set to \"-\", storageClassName: \"\", which disables dynamic provisioning\n## If undefined (the default) or set to null, no storageClassName spec is\n##   set, choosing the default provisioner.  (gp2 on AWS, standard on\n##   GKE, AWS \u0026 OpenStack)\n##\npersistence:\n  enabled: true\n  ## A manually managed Persistent Volume and Claim\n  ## If defined, PVC must be created manually before volume will be bound\n  ## The value is evaluated as a template, so, for example, the name can depend on .Release or .Chart\n  ##\n  # existingClaim:\n\n  ## The path the volume will be mounted at, useful when using different\n  ## PostgreSQL images.\n  ##\n  mountPath: /bitnami/postgresql\n\n  ## The subdirectory of the volume to mount to, useful in dev environments\n  ## and one PV for multiple services.\n  ##\n  subPath: ''\n\n  # storageClass: \"-\"\n  accessModes:\n    - ReadWriteOnce\n  size: 8Gi\n  annotations: {}\n  ## selector can be used to match an existing PersistentVolume\n  ## selector:\n  ##   matchLabels:\n  ##     app: my-app\n  selector: {}\n\n## updateStrategy for PostgreSQL StatefulSet and its reads StatefulSets\n## ref: https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies\n##\nupdateStrategy:\n  type: RollingUpdate\n\n##\n## PostgreSQL Primary parameters\n##\nprimary:\n  ## PostgreSQL Primary pod affinity preset\n  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity\n  ## Allowed values: soft, hard\n  ##\n  podAffinityPreset: \"\"\n\n  ## PostgreSQL Primary pod anti-affinity preset\n  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity\n  ## Allowed values: soft, hard\n  ##\n  podAntiAffinityPreset: soft\n\n  ## PostgreSQL Primary node affinity preset\n  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity\n  ## Allowed values: soft, hard\n  ##\n  nodeAffinityPreset:\n    ## Node affinity type\n    ## Allowed values: soft, hard\n    type: \"\"\n    ## Node label key to match\n    ## E.g.\n    ## key: \"kubernetes.io/e2e-az-name\"\n    ##\n    key: \"\"\n    ## Node label values to match\n    ## E.g.\n    ## values:\n    ##   - e2e-az1\n    ##   - e2e-az2\n    ##\n    values: []\n\n  ## Affinity for PostgreSQL primary pods assignment\n  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity\n  ## Note: primary.podAffinityPreset, primary.podAntiAffinityPreset, and primary.nodeAffinityPreset will be ignored when it's set\n  ##\n  affinity: {}\n\n  ## Node labels for PostgreSQL primary pods assignment\n  ## ref: https://kubernetes.io/docs/user-guide/node-selection/\n  ##\n  nodeSelector: {}\n\n  ## Tolerations for PostgreSQL primary pods assignment\n  ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/\n  ##\n  tolerations: []\n\n  labels: {}\n  annotations: {}\n  podLabels: {}\n  podAnnotations: {}\n  priorityClassName: ''\n  ## Extra init containers\n  ## Example\n  ##\n  ## extraInitContainers:\n  ##   - name: do-something\n  ##     image: busybox\n  ##     command: ['do', 'something']\n  ##\n  extraInitContainers: []\n\n  ## Additional PostgreSQL primary Volume mounts\n  ##\n  extraVolumeMounts: []\n  ## Additional PostgreSQL primary Volumes\n  ##\n  extraVolumes: []\n  ## Add sidecars to the pod\n  ##\n  ## For example:\n  ## sidecars:\n  ##   - name: your-image-name\n  ##     image: your-image\n  ##     imagePullPolicy: Always\n  ##     ports:\n  ##       - name: portname\n  ##         containerPort: 1234\n  ##\n  sidecars: []\n\n  ## Override the service configuration for primary\n  ##\n  service: {}\n  # type:\n  # nodePort:\n  # clusterIP:\n\n##\n## PostgreSQL read only replica parameters\n##\nreadReplicas:\n  ## PostgreSQL read only pod affinity preset\n  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity\n  ## Allowed values: soft, hard\n  ##\n  podAffinityPreset: \"\"\n\n  ## PostgreSQL read only pod anti-affinity preset\n  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity\n  ## Allowed values: soft, hard\n  ##\n  podAntiAffinityPreset: soft\n\n  ## PostgreSQL read only node affinity preset\n  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity\n  ## Allowed values: soft, hard\n  ##\n  nodeAffinityPreset:\n    ## Node affinity type\n    ## Allowed values: soft, hard\n    type: \"\"\n    ## Node label key to match\n    ## E.g.\n    ## key: \"kubernetes.io/e2e-az-name\"\n    ##\n    key: \"\"\n    ## Node label values to match\n    ## E.g.\n    ## values:\n    ##   - e2e-az1\n    ##   - e2e-az2\n    ##\n    values: []\n\n  ## Affinity for PostgreSQL read only pods assignment\n  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity\n  ## Note: readReplicas.podAffinityPreset, readReplicas.podAntiAffinityPreset, and readReplicas.nodeAffinityPreset will be ignored when it's set\n  ##\n  affinity: {}\n\n  ## Node labels for PostgreSQL read only  pods assignment\n  ## ref: https://kubernetes.io/docs/user-guide/node-selection/\n  ##\n  nodeSelector: {}\n\n  ## Tolerations for PostgreSQL read only  pods assignment\n  ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/\n  ##\n  tolerations: []\n  labels: {}\n  annotations: {}\n  podLabels: {}\n  podAnnotations: {}\n  priorityClassName: ''\n\n  ## Extra init containers\n  ## Example\n  ##\n  ## extraInitContainers:\n  ##   - name: do-something\n  ##     image: busybox\n  ##     command: ['do', 'something']\n  ##\n  extraInitContainers: []\n\n  ## Additional PostgreSQL read replicas Volume mounts\n  ##\n  extraVolumeMounts: []\n\n  ## Additional PostgreSQL read replicas Volumes\n  ##\n  extraVolumes: []\n\n  ## Add sidecars to the pod\n  ##\n  ## For example:\n  ## sidecars:\n  ##   - name: your-image-name\n  ##     image: your-image\n  ##     imagePullPolicy: Always\n  ##     ports:\n  ##       - name: portname\n  ##         containerPort: 1234\n  ##\n  sidecars: []\n\n  ## Override the service configuration for read\n  ##\n  service: {}\n  # type:\n  # nodePort:\n  # clusterIP:\n\n  ## Whether to enable PostgreSQL read replicas data Persistent\n  ##\n  persistence:\n    enabled: true\n\n  # Override the resource configuration for read replicas\n  resources: {}\n  # requests:\n  #   memory: 256Mi\n  #   cpu: 250m\n\n## Configure resource requests and limits\n## ref: http://kubernetes.io/docs/user-guide/compute-resources/\n##\nresources:\n  requests:\n    memory: 256Mi\n    cpu: 250m\n\n## Add annotations to all the deployed resources\n##\ncommonAnnotations: {}\n\nnetworkPolicy:\n  ## Enable creation of NetworkPolicy resources. Only Ingress traffic is filtered for now.\n  ##\n  enabled: false\n\n  ## The Policy model to apply. When set to false, only pods with the correct\n  ## client label will have network access to the port PostgreSQL is listening\n  ## on. When true, PostgreSQL will accept connections from any source\n  ## (with the correct destination port).\n  ##\n  allowExternal: true\n\n  ## if explicitNamespacesSelector is missing or set to {}, only client Pods that are in the networkPolicy's namespace\n  ## and that match other criteria, the ones that have the good label, can reach the DB.\n  ## But sometimes, we want the DB to be accessible to clients from other namespaces, in this case, we can use this\n  ## LabelSelector to select these namespaces, note that the networkPolicy's namespace should also be explicitly added.\n  ##\n  ## Example:\n  ## explicitNamespacesSelector:\n  ##   matchLabels:\n  ##     role: frontend\n  ##   matchExpressions:\n  ##    - {key: role, operator: In, values: [frontend]}\n  ##\n  explicitNamespacesSelector: {}\n\n## Configure extra options for startup, liveness and readiness probes\n## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes\n##\nstartupProbe:\n  enabled: false\n  initialDelaySeconds: 30\n  periodSeconds: 15\n  timeoutSeconds: 5\n  failureThreshold: 10\n  successThreshold: 1\n\nlivenessProbe:\n  enabled: true\n  initialDelaySeconds: 30\n  periodSeconds: 10\n  timeoutSeconds: 5\n  failureThreshold: 6\n  successThreshold: 1\n\nreadinessProbe:\n  enabled: true\n  initialDelaySeconds: 5\n  periodSeconds: 10\n  timeoutSeconds: 5\n  failureThreshold: 6\n  successThreshold: 1\n\n## Custom Startup probe\n##\ncustomStartupProbe: {}\n\n## Custom Liveness probe\n##\ncustomLivenessProbe: {}\n\n## Custom Rediness probe\n##\ncustomReadinessProbe: {}\n\n##\n## TLS configuration\n##\ntls:\n  # Enable TLS traffic\n  enabled: false\n  #\n  # Whether to use the server's TLS cipher preferences rather than the client's.\n  preferServerCiphers: true\n  #\n  # Name of the Secret that contains the certificates\n  certificatesSecret: ''\n  #\n  # Certificate filename\n  certFilename: ''\n  #\n  # Certificate Key filename\n  certKeyFilename: ''\n  #\n  # CA Certificate filename\n  # If provided, PostgreSQL will authenticate TLS/SSL clients by requesting them a certificate\n  # ref: https://www.postgresql.org/docs/9.6/auth-methods.html\n  certCAFilename:\n  #\n  # File containing a Certificate Revocation List\n  crlFilename:\n\n\n\n"
            ],
            "verify": false,
            "version": "11.6.15",
            "wait": true,
            "wait_for_jobs": false
          },
          "sensitive_attributes": [],
          "private": "bnVsbA=="
        },
        {
          "index_key": "prometheus-postgres-exporter",
          "schema_version": 0,
          "attributes": {
            "atomic": false,
            "chart": "prometheus-postgres-exporter",
            "cleanup_on_fail": false,
            "create_namespace": false,
            "dependency_update": false,
            "description": null,
            "devel": null,
            "disable_crd_hooks": false,
            "disable_openapi_validation": false,
            "disable_webhooks": false,
            "force_update": false,
            "id": "yantram-prometheus-postgres-exporter",
            "keyring": null,
            "lint": false,
            "manifest": null,
            "max_history": 0,
            "metadata": [
              {
                "app_version": "0.10.1",
                "chart": "prometheus-postgres-exporter",
                "name": "yantram-prometheus-postgres-exporter",
                "namespace": "yantram",
                "revision": 1,
                "values": "{\"config\":{\"datasource\":{\"database\":\"postgres\",\"host\":\"yantram-postgresql\",\"password\":\"postgres\",\"passwordSecret\":{},\"port\":\"5432\",\"sslmode\":\"disable\",\"user\":\"postgres\"}},\"replicaCount\":1,\"service\":{\"annotations\":{},\"labels\":{},\"name\":\"http\",\"port\":80,\"targetPort\":9187,\"type\":\"ClusterIP\"},\"serviceMonitor\":{\"enabled\":true,\"labels\":{\"release\":\"yantram-kube-prometheus-stack\"},\"namespace\":\"yantram\"}}",
                "version": "3.0.3"
              }
            ],
            "name": "yantram-prometheus-postgres-exporter",
            "namespace": "yantram",
            "pass_credentials": false,
            "postrender": [],
            "recreate_pods": false,
            "render_subchart_notes": true,
            "replace": false,
            "repository": "https://prometheus-community.github.io/helm-charts",
            "repository_ca_file": null,
            "repository_cert_file": null,
            "repository_key_file": null,
            "repository_password": null,
            "repository_username": null,
            "reset_values": false,
            "reuse_values": false,
            "set": [],
            "set_sensitive": [],
            "skip_crds": false,
            "status": "deployed",
            "timeout": 300,
            "values": [
              "# Default values for prometheus-postgres-exporter.\n# This is a YAML-formatted file.\n# Declare variables to be passed into your templates.\n\nreplicaCount: 1\n\nservice:\n  type: ClusterIP\n  port: 80\n  targetPort: 9187\n  name: http\n  labels: {}\n  annotations: {}\n\nserviceMonitor:\n  # When set true then use a ServiceMonitor to configure scraping\n  enabled: true\n  labels:\n    release: yantram-kube-prometheus-stack\n  # Set the namespace the ServiceMonitor should be deployed\n  namespace: yantram\n  # Set how frequently Prometheus should scrape\n  # interval: 30s\n  # Set path to cloudwatch-exporter telemtery-path\n  # telemetryPath: /metrics\n  # Set labels for the ServiceMonitor, use this to define your scrape label for Prometheus Operator\n  # labels:\n  # Set timeout for scrape\n  # timeout: 10s\n  # Set of labels to transfer from the Kubernetes Service onto the target\n  # targetLabels: []\n  # MetricRelabelConfigs to apply to samples before ingestion\n  # metricRelabelings: []\n\nconfig:\n  datasource:\n    # Specify one of both datasource or datasourceSecret\n    host: yantram-postgresql\n    user: postgres\n    # Only one of password and passwordSecret can be specified\n    password: postgres\n    # Specify passwordSecret if DB password is stored in secret.\n    passwordSecret: {}\n    # Secret name\n    #  name:\n    # Password key inside secret\n    #  key:\n    port: \"5432\"\n    database: 'postgres'\n    sslmode: disable\n    # Specifies if datasource should be sourced from secret value in format: postgresql://login:password@hostname:port/dbname?sslmode=disable\n    # Multiple Postgres databases can be configured by comma separated postgres connection strings\n    # Secret name\n    #  name:\n    # Connection string key inside secret\n    #  key:\n"
            ],
            "verify": false,
            "version": "3.0.3",
            "wait": true,
            "wait_for_jobs": false
          },
          "sensitive_attributes": [],
          "private": "bnVsbA=="
        }
      ]
    }
  ]
}
